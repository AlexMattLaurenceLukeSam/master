Algo:
//PaperForReview Class has a paper and calculates a score for all the potential reviewers. This is then stored in an
//array (of structs) which has the reviewerID and associated score for that reviewer.

//TODO: getter function for a vector(?) of the reviewers

struct ReviewerBid
{
	int score;
	int reviewerID;
};

class PaperForReview
{
	private:
		int paperID;
		int conferenceID;
		ReviewerBid[numOfReqReviewrs] reviewerBids;

		std::vector<int> authors;
		std::vector<int> involvedOrganisation;
		std::vector<int> conflictingReviewersVec;
		PapersForReview(int);
		~PapersForReview();
		int getMinScore();
		void setNewReviewer(int, int);
		void checkNewReviewer(int, int);
		void addAuthor(int);
		void conflictingReviewers();
		void algo();
		void fillVectors();
		
	public:
		//getter

};

void PaperForReview::checkNewReviewer(int newScore, int newReviewerID)
{
	if(getMinScore() < newscore)
	{
		//Set New Reviewer
		setNewReviewer(newScore, newReviewerID);
		
	}
}

int PaperForReview::getMinScore()
{
	int minScore = -1;
	for(int i=0; i<NumOfReqReviewers; i++)
	{
		if(reviewerBids[i].score < minScore)
			minScore = reviewerBids[i].score;
	}
	return minScore;
}

void PaperForReview::setNewReviewer(int newScore, int newReviewer)
{

	minScore = getMinScore();
	for(int i=0; i< NumOfReqReviewers; i++)
	{
		if(reviewerBids[i].score < minScore)
		{
			reviewerBids[i].score = newScore;
			reviewerBids[i].reviewerID =  newReviewer;
			i=  NumOfReqReviewrs;
		}
	}

}

PaperForReview::~PaperForReview()
{

}

PaperForReview::PaperForReview(int newPaperID, int confID)
{
	paperID = newPaperID
	conferenceID = confID;
	
	for(int i=0; i< NumOfReqReviewrs; i++)
	{
		reviewerBids[i].score = -1;
	}
	
	fillVectors(paperID);
	
	algo(PaperID, confID);
}


void PaperForReview::addAuthor(int newAuthor)
{
	authors.push_back(newAuthor);
}

//TODO
void  PaperForReview::conflictingReviewers()
{
	//authors
		conflictingReviewers.insert(conflictingReviewers.end(), authors.begin(), authors.end());


	//(3)usersFromSameOrganisation
		//ForEachAuthor:   SelectOrganisation
			//SelectAllUsersFromEachOrganisation
				//PushBack^

	//pastCoAuthors
		//(4)ForEachAuthor:   selectAllPapers in temp
			//Select All authors for each paper in temp
				//pushBack^
}




int calculateScore(int userID, int paperID)
{
	int score = 1;

	//(5)&(6)for each keyword match
		 ++score;

	return score;

}

void PaperForReview::algo(int paperID, int conferenceID)
{
	std::vector<int> userIDs;
	
	//(7) fill userIDs with reviewers from conference
	
	 for all in userIDs
	 {
	 	int score = 0;
		If UserID not in  conflictingReviewers
		{
			if(isYES())
			{
				score = calculateScore(userID, paperID) * (isYES()*1000000);
				checkNewReviewer(score, userID);
			}
			elseif(isMAYBE())
			{
				score = calculateScore(userID, paperID) * (isMAYBE()*1000);
				checkNewReviewer(score, userID);
			}
			elseif(!isCONFLICT())
			{
				score = calculate score(userID, paperID);
				checkNewReviewer(score, userID);
			}
		}
	}
}


void fillVectors(int paperID)
{

	// (1)select all Authors where paper==paperID
		//addAuthors to paper

	// (2)select organisation for each author
		//add involved organisation
	
	// CONFLICTING HERE
}

//(1)select author
		//Where Paper ID = ?
		
//(2)select organisation
		//where author = ?
		

//(3) select author
		//where organisation = ?
		
//(4) select paperIDs
		//where Author =?
		
//(5) select keywords
		//where paperID = ?
		
//(6) select keywords
		//where userID = ?
		
//(7) select pcs(reviewrs)
		//where conferfence = ?

