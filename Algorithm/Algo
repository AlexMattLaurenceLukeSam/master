/*
	Algo to be run on server side at bool variable change "allocationDateBool"
	See below for arguments
	
	//takes in paperID, conferenceID, and numReqReviewers for paper
*/

//Algo:
//PaperForReview Class has a paper and calculates a score for all the potential reviewers. This is then stored in an
//array (of structs) which has the reviewerID and associated score for that reviewer.

//USE: Create new PaperForReview with consturctor
//	Use getter function to return reviewers
//	reviewers with a reviewer ID of -1 => not a reviewer


//returns vector of reviewerIDs from getter
#include <iostream>
#include <vector>
#include "Conference.hpp"
#include "Paper".hpp
#include "User.hpp"


struct ReviewerBid
{
	int score;
	int reviewerID;
};

class PaperForReview
{
	private:
		PapersForReview(int, int, int,Database*);
		~PapersForReview();
		int paperID;
		int conferenceID;
		Database* db;
		
		std::vector<ReviewerBid> reviewerBids;
		
		int numOfReqReviewrs;
		
		std::vector<int> authors;
		std::vector<int> involvedOrganisation;
		std::vector<int> conflictingReviewersVec;
		
		int getMinScore();
		void setNewReviewer(int, int);
		void checkNewReviewer(int, int);
		void addAuthor(int);
		void conflictingReviewers();
		void algo();
		void fillVectors();
		//push
		void pushReviewers();

};

std::vector<int> pushReviewers()
{
	
	for(int i=0; i<numOfReqReviewrs; i++)
	{
		if(reviewerBids.score[i] > 1)
		{
			//Push new Reviewer to the database
			//db->reviewerAssigned(paperID,ReviewerBid.reviewerID
		}
	}

}

void PaperForReview::checkNewReviewer(int newScore, int newReviewerID)
{
	if(getMinScore() < newscore)
	{
		//Set New Reviewer
		setNewReviewer(newScore, newReviewerID);
	}
}

int PaperForReview::getMinScore()
{
	int minScore = -1;
	for(int i=0; i<NumOfReqReviewers; i++)
	{
		if(reviewerBids[i].score < minScore)
			minScore = reviewerBids[i].score;
	}
	return minScore;
}

void PaperForReview::setNewReviewer(int newScore, int newReviewer)
{

	minScore = getMinScore();
	for(int i=0; i< NumOfReqReviewers; i++)
	{
		if(reviewerBids[i].score < minScore)
		{
			reviewerBids[i].score = newScore;
			reviewerBids[i].reviewerID =  newReviewer;
			i=  NumOfReqReviewrs;
		}
	}

}

PaperForReview::~PaperForReview()
{

}

PaperForReview::PaperForReview(int newPaperID, int confID, int numReviewers, Database* database)
{
	paperID = newPaperID
	conferenceID = confID;
	db = database;
	
	numOfReqReviewrs = numReviewers;
	
	reviewerBids.resize(numOfReqReviewrs)
	
	for(int i=0; i< numOfReqReviewrs; i++)
	{
		reviewerBids[i].score = -1;
		reviewerBids[i].reviewerID = -1;
	}
	
	fillVectors(paperID);
	
	algo(PaperID, confID);
	
	pushReviewers();
	
	//del???
}


void PaperForReview::addAuthor(int newAuthor)
{
	authors.push_back(newAuthor);
}

//TODO
//populate clonflicting reviewers vector further from database queries
void  PaperForReview::conflictingReviewers()
{
	//authors
		conflictingReviewers.insert(conflictingReviewers.end(), authors.begin(), authors.end());


	//(3)usersFromSameOrganisation
		//ForEachAuthor:   SelectOrganisation
			//SelectAllUsersFromEachOrganisation
				//PushBack^

	//pastCoAuthors
		//(4)ForEachAuthor:   selectAllPapers into temp
			//Select All authors for each paper in temp
				//pushBack^
}



//TODO: matching keywords from database returns
int calculateScore(int userID, int paperID)
{
	int score = 1;

	//(5)&(6)for each keyword match
		 ++score;

	return score;

}


//TODO:get reviewer pref
void PaperForReview::algo(int paperID, int conferenceID)
{
	std::vector<int> userIDs;
	
	//(7) fill userIDs with reviewers from conference
	
	 for all in userIDs
	 {
	 	int score = 0;
		If UserID not in  conflictingReviewers
		{
			int reviewersPreference = 0;
					// 1=yes
					//2=maybe
					//3=conflict
			reviewersPreference = ;//(8)GET PREF FROM DATABASE fetchreviewerPreference(userID, paperID);
			
			if(reviewersPreference == 1)
			{
				score = calculateScore(userID, paperID) * 1000000;
				checkNewReviewer(score, userID);
			}
			elseif(reviewersPreference == 2)
			{
				score = calculateScore(userID, paperID) * 1000;
				checkNewReviewer(score, userID);
			}
			elseif(reviewersPreference != 3)
			{
				score = calculate score(userID, paperID);
				checkNewReviewer(score, userID);
			}
		}
	}
}


//TODO: populate vectors from data base
//TODO: call conflicting reviewers

void fillVectors(int paperID)
{

	// (1)select all Authors where paper==paperID
		//addAuthors to paper

	// (2)select organisation for each author
		//add involved organisation
	
	//CONFLICTING HERE
		conflictingReviewers();
}


//MAY NEED TO FILTER FOR CONFERENCE ASWELL
//(1)select author
		//Where Paper ID = ?
		
//(2)select organisation
		//where author = ?
		

//(3) select author
		//where organisation = ?
		
//(4) select paperIDs
		//where Author =?
		
//(5) select keywords
		//where paperID = ?
		
//(6) select keywords
		//where userID = ?
		
//(7) select pcs(reviewrs)
		//where conferfence = ?
		
//(8) select reviewerPreferance
		//where reviewerID = ? and paperID = ? 

